# 데이터의 표현

>본 글은 아래 강의를 바탕으로 작성되었습니다.
>
>[CSA2021 컴퓨터시스템구조 제 3 장 Part-1](https://youtu.be/aSocCv3SC2k)
>
>[CSA2021 컴퓨터시스템구조 제 3 장 Part-2](https://youtu.be/bysGzutpRgc)

<br>

## 목차

[1. 데이터의 종류](#1-데이터의-종류)

[2. 보수](#2-보수)

[3. 고정 소수점 표현](#3-고정-소수점-표현)

[4. 부동 소수점 표현](#4-부동-소수점-표현)

[5. 기타 이진 코드](#5-기타-이진-코드)

[6. 에러 검출 코드](#6-에러-검출-코드)

<br>

## 1. 데이터의 종류

컴퓨터에서 데이터의 종류는 보통 레지스터에 저장되는 데이터의 종류를 의미하며 크게 세 가지로 분류된다.

- 산술 연산용 숫자(Numeric): 컴퓨터의 시작은 산술 연산을 위한 도구였다.
- 데이터 처리용 영문자(Alpha): 대소문자 총 52자
- 특수 목적용 기호(Special)

### 진수와 진법

- radix: 진법의 기수(10, 2, 8, 16 등)
- 10진수, 2진수, 8진수, 16진수
- 2진화 8진수(Octal), 2진화 16진수(Hexadeciamal), 2진화 10진수(Binary Code Decimal, BCD)

### 영숫자(AlphaNumeric)의 표시

- ASCII Code: 7 bits + 1 parity bit
- EBCDIC Code: 16 bits, IBM internal code
- UniCode: 16 bits/32 bits, 영문자와 숫자는 UTF-16이나 UTF-32에서도 길이만 다른 같은 값을 갖는다.

> #### Special Communication Data
>
> - Morse Code
> - Flag Signal(Red/White flags), 수기 신호

<br>

## 2. 보수

보수는 진법의 기수(`r`)에 대응하는 역(reverse) 값이다. 뺄셈과 논리 계산에 사용된다.

### `r-1`의 보수 체계

- 10의 보수를 위해 9's complement 사용
  - 99999 - 12389 = 87610
- 2의 보수를 위해 1's complement 사용
  - 1111111 - 0001111 = 1110000

### `r`의 보수 체계

- 10's complement 
  - 100000 - 12389 = 87611
- 2's complement 1
  - 0000000 - 0001111 = 1110001

### 부호 없는 숫자의 뺄셈

컴퓨터는 덧셈을 이용해 뺄셈 연산을 수행한다. 이때 보수가 사용된다. 보수를 더한 뒤 자릿수를 정리하면 그 결과가 뺄셈의 결과가 된다.

<br>

## 3. 고정 소수점 표현

레지스터 비트에 소수점의 위치를 표시하는 것을 고정 소수점 표현이라 한다. 하지만 일반적으로 고정 소수점 표현은 정수를 표현하는 데 주로 사용되기 때문에 16 bits 정수의 경우 일반적으로 최우측(LSB)에 소수점 자리를 위치시킨다. 실수를 표현하기 위해서는 주로 부동 소수점을 이용하며 이때 레지스터 비트의 앞, 중간에 소수점 자리가 위치하게 된다.

### 정수의 표현(`-14` 표현)

- MSB(Most Significant Bit)로 부호를 표현한다.
  - 양수는 0, 음수는 1이다.
- 숫자의 표현에는 다음 세 방법이 있다.
  - 부호 절댓값 표현(signed magnitude)
    - 1 0001110
  - 부호화된 1의 보수(signed 1's complement)
    - 1 1110001
  - 부호화된 2의 보수(signed 2's complement)
    - 1 1110010
    - 대부분의 컴퓨터, CPU에서는 이 방법을 사용한다.

### 오버플로우(Overflow)

오버플로우는 두 수의 합을 표현하기 위해서 레지스터의 비트 수보다 큰 비트가 필요할 때 발생한다. 이는 가수, 피가수의 부호와 관계없이 발생하며 정해진 비트 수 내에서만 연산이 가능한 컴퓨터의 한계로 인해 생기는 문제이다. 오버플로우는 두 수의 부호가 같을 경우에만 발생하며 발생 시 레지스터에 저장된 결과는 잘못된 값을 갖게 된다.

오버플로우를 처리하기 위해서는 발생을 미리 확인해 막아야 한다. 오버플로우는 MSB의 두 캐리 비트의 값이 서로 다를 경우 발생하기 때문에 두 캐리 비트의 Exclusive OR 연산 결과가 1이라면 오버플로우가 발생할 것을 알 수 있다. 컴퓨터는 이 경우 연산을 처리하지 않고 인터럽트 또는 에러 처리를 한다.

<br>

## 4. 부동 소수점 표현

### 부동 소수점 표시 방법(IEEE 754)

부동 소수점은 가수와 지수로 표현된다.

> 가수 Mantissa: 분수(fraction), 정수 값 표시
>
> 지수 Component: 십진/이진 소수점 위치를 표시

|            | Fraction                    | Component |                       |
| ---------- | --------------------------- | --------- | --------------------- |
| + 6231.789 | + 0.6142789                 | + 04      | + (.0.6142789) * 10^4 |
| + 1001.11  | 01001110 (8 bits 자리 채움) | 00100     | + (.1001110) * 2^4    |

`+ 1001.11`의 결과 `+ (.1001110) * 2^4` 값을 32 bits FP로 표현하면 다음과 같은 결과가 나온다.

`0 10000100 00111000000000000000000`

- 맨 앞의 비트는 부호를 표시한다.
- 두 번째 묶음으로 나뉜 비트는 component를 표현한다. 이때 128 biased로 표현되기 때문에 맨 앞의 비트가 1이 된다.
  - 128 biased: 128을 0과 같은 기준으로 잡는다. 즉 127은 -1, 126은 -2가 될 것이다.
- 세 번째 묶음으로 나뉜 비트는 fraction을 표현한다. 이때 가장 좌측의 1은 제거된다. 만약 가장 좌측의 수가 0이었다면 애초에 소수점의 위치가 현재 위치가 아닐 것이다. 즉 소수점 다음의 수는 무조건 1이 된다. 따라서 한 개의 비트를 더 아껴 더 많은 수를 표현하기 위해 가장 좌측의 1은 표현하지 않는다.

가수와 지수를 저장하는 비트의 수는 그 크기에 따라 달라진다. 16 bits의 표현 방법보다는 32 bits의 표현 방법이, 32 bits의 표현 방법보다는 64 bits의 표현 방법이 더 많은 수를 저장할 수 있으며 따라서 더 정밀한 값을 나타낼 수 있게 된다. 하지만 소수점 이하 수의 개수가 많지 않은데 64 bits의 표현 방법을 쓴다면 메모리를 낭비하게 되므로 적절한 방법을 선택해야 한다.

### 정규화(Normalization)

- 부동소수점 숫자에서 최상위 비트가 0이 아닌 경우
- 0이 있으면 가수의 소수점 위치를 이동하고 이동한 만큼 exponent의 값을 변경한다

<br>

## 5. 기타 이진 코드

### Grey Code

Grey code는 한 숫자에서 다음 숫자로 변할 때 하나의 비트만이 바뀐다. 일반적으로 전기 신호 제어 계통에서 주로 사용된다. 여러 전기 신호가 동시에 바뀔 때 에러가 적게 발생한다는 장점이 있기 때문이다.

### BCD Code

10진수를 2진수로 표현한 것이며 8421 code라고도 불린다. 4 bits를 사용하여 0부터 9까지 사용한다(0000\~1001).

### Excess-3 Code

Binary code에 3을 더한 게 excess-3 code이다. 즉 BCD code에 0011을 더한 것이다. 암호 교신의 기본 코드이며 파생 암호 발생 방법에 사용된다.

### 기타 영문 Code

- ACSII: 7 bits + parity 1 bit

- EBCDIC: 8 bits + parity 1 bit

<br>

## 6. 에러 검출 코드

### Parity bit

외부 잡음에 의해 에러가 발생할 때 이를 검출한다. 패리티에는 짝수 패리티와 홀수 패리티가 있다. 만약 데이터 비트에서 1의 개수가 짝수개 있다면 짝수 패리티는 0이고 홀수개 있다면 1이다. 홀수 패리티는 1의 개수가 홀수개일 때 0이며 짝수개일 때 1이다. 패리티를 이용하면 간단하게 에러가 발생했는지 알 수 있지만 2개의 비트에서 동시에 에러가 발생한 경우는 검출할 수 없다.

송신 측은 패리티 발생기를 통해 패리티를 보내고 수신 측은 패리티 검사기를 통해 패리티를 검사한다. 만약 데이터 패리티와 일치한다면 에러가 없기 때문에 0을 출력하고 불일치한다면 에러가 발생한 것이므로 1을 출력한다.

