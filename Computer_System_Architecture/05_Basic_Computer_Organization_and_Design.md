# 기본 컴퓨터의 구조와 설계 

> 본 글은 아래 강의를 바탕으로 작성되었습니다.
>
> [CSA2021 컴퓨터시스템구조 제 5 장 Part-1-1](https://youtu.be/vSnpYzCuwVY)
>
> [CSA2021 컴퓨터시스템구조 제 5 장 Part-1-2](https://youtu.be/T2oKxvinK84)
>
> [CSA2021 컴퓨터시스템구조 제 5 장 Part-2-1](https://youtu.be/eoswnrO_v9g)
>
> [CSA2021 컴퓨터시스템구조 제 5 장 Part-2-2](https://youtu.be/zQuOYWLbCI4)

<br>

## 목차

[1. 명령어 코드](#1-명령어-코드)

[2. 컴퓨터 레지스터](#2-컴퓨터-레지스터)

[3. 컴퓨터 명령어](#3-컴퓨터-명령어)

[4. 타이밍과 제어](#4-타이밍과-제어)

[5. 명령어 사이클](#5-명령어-사이클)

[6. 메모리 참조 명령어](#6-메모리-참조-명령어)

[7. 입출력과 인터럽트](#7-입출력과-인터럽트)

[8. 컴퓨터에 대한 완전한 기술](#8-컴퓨터에-대한-완전한-기술)

[9. 기본 컴퓨터의 설계](#9-기본-컴퓨터의-설계)

[10. 누산기 논리의 설계](#10-누산기-논리의-설계)

<br>

## 1. 명령어 코드

### 컴퓨터의 동작

컴퓨터의 동작은 레지스터 내의 저장된 데이터에 대한 마이크로 연산의 집합인 마이크로 연산 시퀀스에 의하여 정의된다. 범용 컴퓨터 시스템에서는 다양한 마이크로 연산 시퀀스를 정의하고 이에 따라 컴퓨터는 동작한다.

### 명령어 코드

명령어 코드는 컴퓨터에 어떤 동작을 수행할 것을 알리는 비트들의 집합이다. 

### 컴퓨터 명령어

컴퓨터 동작을 위한 일련의 마이크로 연산을 컴퓨터 명령어라 한다. 이는 이진 코드로 구성되어 있고 데이터와 함께 메모리에 저장된다.

### 프로그램

사용자가 원하는 연산과 피연산자가 처리되는 순서를 기술한 컴퓨터 명령어의 집합이 프로그램이며 명령어 처리 과정을 제어한다.

### 내장 프로그램

내장 프로그램은 제어 신호에 의해 명령어의 이진 코드를 해석하여 실행한다. 명령어를 저장하여 실행하는 컴퓨터 구동 방식을 따른다.

### 저장(내장) 프로그램 구조

명령어는 명령어 포맷(instruction format)에 따라서 정의되며 이러한 명령어의 집합으로 프로그램이 구성된다. 프로그램 실행 부분(opcode)에 따라서 명령어와 데이터는 메모리의 다른 부분(segment)에 저장되며 명령어 실행 결과는 AC(accumulator)에 저장된다. 가장 기본적인 segment는 code segment, data segment, stack segment이다.

### 간접주소 시스템

기본적인 16 비트 명령어의 instruction format을 살펴보면 0에서 11 번째 비트까지 주소를 나타내고 12에서 14 번째 비트까지는 opcode, 마지막 15번째 비트는 간접 주소인지, 직접 주소인지를 나타낸다. 많은 경우 직접 주소를 이용하여 데이터를 지칭한다. 15번째 비트가 0인 경우 직접 주소를 나타내며 1인 경우 간접 주소를 나타낸다. 간접 주소는 해당 주소에 있는 값이 실제 데이터의 값이 아닌 실제 데이터의 주소이다. 따라서 한 번 더 주소를 찾아야 한다. 이런 방법은 활용성을 높이기 때문에 꼭 필요하다.

<br>

## 2. 컴퓨터 레지스터

### 기본 컴퓨터 레지스터 종류

![](https://upscfever.com/upsc-fever/en/gatecse/images/computer-design3.png)

### 버스 시스템 종류

- 내부 버스
  - CPU(컴퓨터) 내부의 레지스터 간 연결
- 외부 버스
  - CPU 내부 레지스터와 메모리 간 연결
- 입출력 버스
  - CPU와 주변 장치 간 연결

### 공통 버스 시스템

내부 버스는 보통 공통 버스 시스템이라 통칭한다. 한 번에 전송할 수 있는 데이터의 크기를 내부 버스의 크기(width)라 하며 이 크기로 인해 CPU 워드 크기가 결정된다.

> 16 bits 컴퓨터: 내부 버스/레지스터 크기가 16 bits
>
> 32 bits 컴퓨터: 내부 버스/레지스터 크기가 32 bits

버스는 레지스터와 레지스터 또는 레지스터와 메모리 사이의 데이터 전송 통로이며 버스에는 한 시점에 하나의 전송 신호만이 존재할 수 있다. 따라서 2개 이상의 신호가 발생하면 버스 충돌이 발생하기 때문에 정확한 타이밍과 MUX 제어를 수행하기 위한 버스 제어기가 필요하다.

공통 버스 시스템에서 레지스터 출력은 버스의 MUX 입력에 연결되어 있다. 각 레지스터에는 MUX 입력번호가 설정되어 있고 레지스터 입력은 버스에 직접 연결되어있다.

<br>

## 3. 컴퓨터 명령어

### 기본 컴퓨터 명령어의 종류

- MRI(Memory Reference Instruction) 명령 7가지
- RRI(Register Reference Instruction) 명령 12가지
- IO(Input Output Instruction) 명령 6가지

![](https://brightways.org/images/instrcution-set-completeness.png)

<br>

## 4. 타이밍과 제어

### 명령어 실행 타이밍 예

- D3T4: SC <- 0
- D3과 T4가 1일 때 Sequence Counter가 1이 되고 따라서 SC가 0으로 clear 된다. 
- 이러한 제어가 control logic gates(제어 장치)에서 일어난다.

<br>

## 5. 명령어 사이클

### 명령어 사이클 단계

1. 메모리에서 명령어 가져오기(Fetch, code segment에 있던 명령어를 버스를 통해 가져온다.)
2. 명령어 디코딩
3. 유효주소(effective address) 계산(실제 데이터가 있는 주소를 알아내는 과정. 간접 주소일 때에는 한 단계 더 들어가야 했었다.)
4. 명령어 실행

모든 명령어는 그 종류와 상관없이 반드시 1단계와 2단계를 거치며 이 두 단계를 fetch cycle이라 한다.

### Fetch와 Decode

- T0: AR <- PC
  - PC(Program Counter) 레지스터는 현재 가져와야 할 명령어의 주소를 기억하고 있다.
  - PC 값을 AR로 보내면 AR은 메모리의 해당 주소에 있는 데이터를 가져올 수 있다.
- T1: IR <- M[AR], PC <- PC + 1
- T2: D0 \~ D7 <- decode IR(12\~14), AR <- IR(0\~11), I <- IR(15)

### 명령어의 종류 결정

- MRI 명령어 여부
- RRI 명령어 여부
- IO 명령어 여부

### 레지스터 참조 명령어의 종류와 동작

![](https://padakuu.com/image/Capture(41).png)

<br>

## 6. 메모리 참조 명령어

### 메모리 참조 명령어의 종류와 동작

- AND
- ADD
- LDA
- STA
- BUN
- BSA
- ISZ

<br>

## 7. 입출력과 인터럽트

### 입출력 구성

CPU와 IO 장치의 속도 차이가 매우 크기 때문에 이를 제어가히 위하여 Flag를 사용한다.

- FGI
  - 1: 입력 가능한 상태
  - 0: 입력 블럭킹
- FGO
  - 1: 출력 가능한 상태
  - 0: 출력장치 사용중
- 인터럽트
  - IEN flag에 의하여 입출력을 제어한다. 즉 입출력의 발생은 곧 인터럽트의 발생이다.
  - 입출력 전체를 제어(1일 때 입출력 가능, 0일 때 불가능)

### 입출력 명령어

![](https://upscfever.com/upsc-fever/en/gatecse/images/computer-design17.png)

### 프로그램 인터럽트

입출력 장치가 준비되면 이를 CPU에게 알린다. 이후 인터럽트가 발생하면 BSA 명령어처럼 동작한다. 이때 인터럽트는 FGI, FGO 플래그가 하나 이상 1이 되는 것이며 따로 무언가 발생하는 것이 아니다. 플래그가 set 되면 R이 1이다. R이 0이면 인터럽트가 발생하지 않은 것이다. R이 1이면 다음 명령어 사이클에 인터럽트 사이클을 실행한다. 

### I/O Program

I/O program은 입출력 인터럽트 처리 루틴의 집합이다.

### IVT(Interrupt Vector Table)

각 인터럽트에 벡터 번호를 부여하여 벡터 번호와 인터럽트 처리 루튼 시작 번지를 table로 유지한다. 시스템 부팅 시에 IVT는 0번 segment에 load한다. 현대의 대부분의 CPU는 IVT를 사용한다.

### 인터럽트 사이클(IC)

<br>

## 8. 컴퓨터에 대한 완전한 기술

### 기본 컴퓨터(PDP-11)의 전체 명령어 set

![](https://d2vlcm61l7u1fs.cloudfront.net/media%2Fde2%2Fde2b4fe7-1627-4aee-88b6-0c93f51cb651%2FphpVr8P2D.png)

<br>

## 9. 기본 컴퓨터의 설계

### 기본 컴퓨터

DEC Corp사의 중형 컴퓨터 PDP-11을 지칭하며 이후 VAX-11 등의 주요 minicomputer의 기본이 되었다(1970\~1980년대). 이후 컴퓨터 구조 설계의 가장 기본적인 부분이 되었고 현대의 CPU에도 동일하게 적용되는 설계 구조로 되어 있다.

### 하드웨어 구성요소

- 16 bit 4096 워드 메모리(4k 메인 메모리)
- 9개의 레지스터
  - AR, PC(12 bit 주소 레지스터), DR, AC, IR, TR(16 bit 범용 레지스터), OUTR, INPR(8 bit 입출력 전용 레지스터), SC(register의 변형이 counter)
- 7개의 플립플롭
  - I(direct, indirect 표시), S(현재 accumulator에 들어 있는 값이 양수인지 음수인지 기록하는 sign), E(계산 결과 오버플로우가 발생하면 이를 표시), R(인터럽트 발생 기록), IEN(인터럽트를 받을 것인지 아닌지 기록), FGI, FGO
- 2개의 디코더
  - 3x8(Opcade), 4x16(타이밍)
- 16 bit 공통버스(멀티플렉서)
- 제어 논리 게이트(제어 장치)
- AC 입력 연결 논리회로(ALU)

### 컴퓨터의 동작 흐름

- MRI, RRI, IO 명령 사이클 구현
- 인터럽트 사이클 구현

### 레지스터와 메모리에 대한 제어

### 공통 버스에 대한 제어

<br>

## 10. 누산기 논리의 설계

### AC 레지스터 관련 회로

- AC를 변경하는 경우 수집
- LD, CLR, INC
- LD 신호 제어
  - MRI 명령: AND, ADD, LDA
  - RRI 명령: COM, SHR, SHL
  - IO 명령: INPR
- INR 신호 제어
  - MRI 명령: none
  - RRI 명령: INC
  - IO 명령: INPR
- CLR 신호 제어
  - MRI 명령: none
  - RRI 명령: CLR
  - IO 명령: INPR

### 가산 논리 회로

- 회로 요소
  - AND gate
  - Full Adder
  - Inverter
  - Shifter
  - INPR/OUTR
