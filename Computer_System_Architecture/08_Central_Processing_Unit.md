# 중앙처리장치

> 본 글은 아래 강의를 바탕으로 작성되었습니다.
>
> [CSA2021 컴퓨터시스템구조 제 8 장 Part-1](https://youtu.be/-Y2-gdesND8)
>
> [CSA2021 컴퓨터시스템구조 제 8 장 Part-2](https://youtu.be/uQrRlccgSs4)
>
> [CSA2021 컴퓨터시스템구조 제 8 장 Part-3](https://youtu.be/k1WHtG0zk0g)

<br>

## 목차

[1. 범용 레지스터 구조](#1-범용-레지스터-구조)

[2. 스택 구조](#2-스택-구조)

[3. 명령어 형식](#3-명령어-형식)

[4. 어드레싱 모드](#4-어드레싱-모드)

[5. 데이터 전송과 처리](#5-데이터-전송과-처리)

[6. 프로그램 제어](#6-프로그램-제어)

[7. 간소화된 명령어 집합 컴퓨터](#7-간소화된-명령어-집합-컴퓨터)

<br>

## 1. 범용 레지스터 구조

### CPU 주요 요소

- 기억 장치
  - 레지스터 집합
  - 데이터 임시 저장 장소
- 제어 장치
  - CPU 명령어 처리 회로의 집합
  - 논리 게이트와 요소들로 구성
  - 명령어에 따라서 연산 제어 수행
- 연산 장치
  - ALU
  - 산술 연산, 논리 연산 및 시프트 연산 수행

### 공통 ALU를 가진 레지스터 집합

- 7개의 범용 레지스터
- 3x8 디코더 1개
- 8x1 MUX 2개
- ALU

### 제어 워드 집합

제어 워드는 명령어를 수행시키는 데 필요로 하는, 제어 장치에 들어가는 비트의 집합이다.

- SELA, SELB: ALU 입력 결정
- SELD, ALU 출력 저장소 결정
- OPR: 연산의 종류 지정

<br>

## 2. 스택 구조

### 레지스터 스택

메모리의 일부분 또는 레지스터를 이용해 스택을 만들 수 있다. Upward growing stack으로 구현된다면 데이터가 저장될 때 SP가 증가한다.

### 메모리 스택

메모리의 일부분을 스택으로 사용하는 방법이다. Downward growing stack으로 구현된다면 데이터가 저장될 때 SP가 감소한다.

### 메모리 세그먼트

일정하게 구획해놓은 메모리의 단위를 세그먼트라 한다. 가상 환경에선 page, 물리 메모리에선 블록이라 칭하기도 한다. 모든 프로그램은 무조건 세 개의 세그먼트(Code/Data/Stack(Heap))를 갖는다. 이 세 개의 세그먼트가 합쳐져 하나의 프로세스를 이룬다.

- 세그먼트의 크기
  - MS-DOS/Windows: 64KB
  - UNIX/Linux: N x 1KB 블록

### 스택 오버플로우

스택의 크기를 벗어나는 SP 값에 접근하려 하면 스택 오버플로우가 발생한다. 이는 세그먼트의 크기가 제한되어있기 때문에 할당된 메모리가 부족하면 메모리 영역을 넘어가 다른 프로세스의 영역을 침범하려 한다. 이를 막기 위해 스택 오버플로우 에러를 발생시킨다.

- Protected mode에서 발생

### 연산자 표기 방식

- Infix
- Prefix
- Postfix(대부분의 CPU가 사용하는 방식)

<br>

## 3. 명령어 형식

### 단일 누산기 구조

모든 연산이 AC를 중심으로 구성되어 있다.

### 범용 레지스터 구조

### 스택 구조

<br>

## 4. 어드레싱 모드

### 다양한 어드레싱 모드의 사용 이유

- Pointer, counter indexing 기능 제공
- 프로그램 재배치 편의 제공
  - 프로그래밍의 융통성 제공
- 명령어 주소 필드 최소화

### Implied 모드

- 피연산자가 묵시적으로 정의
- AC 또는 스택에 피연산자 위치

### Immediate 모드

- 피연산자가 명령어 자체에 있음
- 상수를 레지스터에 초깃값으로 주는 경우 사용

### 레지스터 직접 모드

- CPU 내 레지스터에 피연산자 존재

### 레지스터 간접 모드

- 명령어가 피연산자의 주소를 가지고 있는 레지스터를 지정
- 직접 주소보다 적은 어드레스 비트 사용

### 자동증가/자동감소 모드

- 메모리 접근 후, 레지스터값이 자동으로 증가/감소

### 직접 주소 모드

- 명령어의 주소 부분이 유효주소(EA)를 표시
- 분기 명령에서는 실제 분기 주소 표시

### 간접 주소 모드

- 명령어 주소 부분에 유효주소를 지정하는 주소 표시
- 다양한 간접주소 모드 사용
- 유효주소의 계산
  - 유효 주소(EA) = 명령어 주소 부분(ADDR) + CPU 내 특정 레지스터 값

### 상대 주소 모드

- 유효주소 = 주소 필드 값과 프로그램 카운터 값의 합(EA = ADDR + PC)

### 인덱스 어드레싱 모드

- 유효주소 = 주소 필드값과 인덱스 레지스터값의 합(EA = ADDR + XR)
- 배열(Array)의 각 원소에 대한 인덱스 주소 계산에 사용

### 베이스 레지스터 어드레싱 모드

- 유효주소 = 주소 필드값과 베이스 레지스터 값의 합(EA = ADDR + BR)
- Protected 모드의 메모리에서 세그먼트 주소 인덱싱에 사용

<br>

## 5. 데이터 전송과 처리

### 데이터 처리 명령어

- 산술 명령어
- 논리 연산 및 비트 처리 명령어
- 시프트 명령어

<br>

## 6. 프로그램 제어

### 상태 비트 조건

- C: ALU 출력 캐리 값
- S: AC의 부호 비트
- Z: AC 값의 zero 여부
- V: 연산 결과 오버플로우 여부

### 조건부 분기 명령어

- 상태 비트에 따라서 분기

### 서브루틴 Call

### 순환 서브루틴

- 서브루틴이 자기 자신을 호출
- 순환 call이 return 주소를 지워버리는 것을 방지하기 위하여 스택에 return 주소를 저장

### 프로그램 인터럽트

- 인터럽트와 서브루틴의 차이점
  - 시스템 내 외부적 신호에 의하여 프로그램 진행 변경
  - 인터럽트 처리 루틴의 주소는 하드웨어적으로 결정되어 있음
  - PC 값만이 아니라 CPU의 다른 상태를 나타내는 정도도 대피(메모리에 저장)
- PSW(Program Status Word)
  - 인터럽트가 발생할 때 저장하는 CPU 정보
  - PSW로 저장되는 데이터
    - 프로그램 카운터(PC)의 값
    - 모든 레지스터의 값
    - 상태 조건 비트(C, S, V, Z)

### 인터럽트의 형태

- 외부 인터럽트
  - 입출력 장치, 타이밍 장치, 전원 등 외부 요소에 의하여 발생
- 내부 인터럽트
  - 불법적인 명령이나 데이터를 사용할 때 발생
- 소프트웨어 인터럽트
  - 명령어의 수행에 의하여 발생
  - Supervisor call 명령, system call

<br>

## 7. 간소화된 명령어 집합 컴퓨터

### RISC(Reduced Instruction Set Computer) 개요

- 1980년 UC Berkeley David. A. Patterson 교수가 설계
- CISC(Complex Instruction Set Computer)에 비하여 새로운 설계 개념 제시
- 새로운 마이크로 아키텍쳐와 명령어 구조 제시
- MIPS, ALPHA, PowerPC, SPARC, PA-RISC

### CISC vs. RISC

- CISC
  - 많은 수의 명령어
  - 특별한 명령을 수행하는 일부 명령어는 자주 사용되지 않음
  - 다양한 어드레싱 모드 사용
  - 가변 길이 명령어 형식
  - 메모리에서 피연산자 처리
- RISC
  - 상대적으로 적은 수의 명령어
  - 상대적으로 적은 수의 어드레싱 모드
  - 메모리 참조는 load/store 명령으로만 제한
  - 모든 동작은 CPU 내 레지스터에서 수행
  - 고정된 길이의 명령어 형식 사용
  - 단일 사이클의 명령어 실행
  - 하드와이어 제어방식 사용

### RISC 프로세서의 특징

- 적은 수의 명령어로 인한 장점
  - 제어 장치의 간소화로 여유 공간 확보
  - 많은 수의 레지스터(128개 이상)
  - 제어 장치를 하드와이어 방식으로 구현
- 효과적인 명령어 파이프라인 사용
- 프로시저의 빠른 호출/복귀를 위한 중첩된 레지스터 윈도우 사용
- 빠르고 효과적인 구조의 컴파일러
- 고정 길이 명령어 사용으로 간단한 디코딩
- 단일 사이클의 명령어 실행

### 중첩된 레지스터 윈도우

- 프로시저에 사용할 파라미터를 전달
- 중첩된 윈도우를 통하여 보호 모드에서 빠른 데이터 전달
- 많은 수의 레지스터로 인한 구조적 장점